
'''
* 리스트의 내부 요소 다루기

- 리스트는 시퀀스 자료형이기 때문에 인덱스를 통한
요소들의 관리가 가능합니다.
- 리스트를 다룰 때는 문자열과 비슷한 방식을 사용합니다.
'''

foods = ['짜장면', '탕수육', '간짜장', '볶음짬뽕', '목화솜탕슉']

print(foods[2])
print(foods[1][2])
print(foods[0][:2]) # 배열의 첫번째 인덱스값에서 (문자에서의 배열)2번째 인덱스미만까지 출력

# 리스트 슬라이싱 -> 리스트데이터 [begin:end:step]
nums = [0,1,2,3,4,5,6,7,8,9]

print(nums[2:5:1])  # 2번째 인덱스부터 5번째 인덱스 미만까지 1개씩 출력
print(nums[:4]) # 4번 인덱스 미만까지
print(nums[1:7:2]) # 1번 인덱스 이상 7번째 인덱스 미만 2개씩 건너서 출력

# 리스트는 인덱싱을 사용하여 변수처럼 내부의 값을 변경하는 것이 자유롭습니다.
print('=' * 40)

print(nums)

nums[2] = 34
print(nums) # 2번 인덱스 값: 2 -> 34 로 변경

nums[7] = 88
print(nums)

nums[2] = nums[6]
print(nums)

print('=' * 40)

'''
- 문자열은 상수 형태로 저장되는 고정형 리스트입니다. (= 선언하는 순간 끝)
- 따라서 인덱싱이나, 슬라이싱을 통해 값의 복사본을 활용하는 것은
가능하지만, 영역에 직접 접근해서 내부의 값을 편집할 수는 없습니다.
- 문자열은 변경이 불가능한 자료형입니다. (immutable)
- 자바에서도 불가능 했음: 문자열이 하나로 저장되기 때문에 char배열로 값을 재할당 하고 싶다면 새롭게 선언해서
  하나로 저장된 문자열 자체의 값을 변경 해 줘야 한다 -> 모든 언어가 이럼 (문자열에서)
'''
s = 'python'
# s[2] = 'x'

# unpackaging: 리스트 내부 요소를 변수에 각각 저장
f1 = foods[0]
f2 = foods[1]
f3 = foods[2]
f4 = foods[3]
f5 = foods[4]

# 좌항의 변수의 개수와 우항의 리스트의 요소의 개수가 일치한다면
# 자동으로 변수에 리스트 내부 요소의 값들이 차례대로 할당됩니다.
# Javascript의 디스트럭쳐링과 유사!
f1, f2, f3, f4, f5 = foods
print(f1, f2, f3, f4, f5)

# 빈 리스트 만들기
list1 = []

list2 = list()
print(list2)